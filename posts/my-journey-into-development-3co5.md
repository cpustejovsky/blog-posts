# Introduction

I was always a nerd, a geek. But never a computer geek. It was always theology or history or philosophy or politics. 

From middle school onward, I wanted to be a pastor. I learned everything I could both about theology. I networked with every pastor and seminary professor I could. I even learned good people skills (my later diagnosis of being high-functioning autistic sheds this in a miraculous light).

But right as I was about to mail the deposit to seminary, I decided not to go. I could be a great pastor... for about five years. I knew I would burn out. I knew dealing with people couldn't be my primary, day-in-day-out job.

I took a gap year to try to start my own project, but I realized that not just being a pastor, but everything in the humanities was not a path for me and my career.

So I did a 180 and dived into programming. And for the last two and a half years, it's been my goal. However, I've made some missteps and taken detours along the way.

# Why Programming?

**Programming is simple!** It's not easy, but it's simple. Computers do exactly what you tell them to. Problems and bugs and errors can be solved. There is a solution, even if it takes hours or days to come to.

People are complex and complicated. To stay entirely within the realm of programming, what's simpler? Debugging JavaScript code or convincing a JavaScript hater that JavaScript is awesome? 

That simplicity does my brain good. There's nothing like it. Maybe video games, but there are two problems there:
1. I can't make a career playing video games.
2. I don't get a real sense of satisfaction from beating a video game.

Programming provides me with both a sense of accomplishment and a career path.

So programming puts me in a Zen state. And when I say programming, I mean the whole shebang. **Debugging, Googling errors, boilerplate code, all of it puts me in a good brain space.** Obviously building stuff is the best, but I enjoy even the least enjoyable parts of programming.

# Detour Through Marketing

I took a marketing job because I wanted to start adulting sooner rather than later. I knew I could get a content marketing job quickly and a development job would take longer. So I took that path. If nothing else, it helped me realize that even writing (which I love) wasn't a career for me.

However, I made all our website copy changes on a Pug template that went through a full process via git and GitLab. As odd as it sounds, editing copy actually got me some amazing experience at contributing to a large repository with other people working on it. I learned how to resolve merge conflicts and fix my branch and cherry-pick commits all from the command line. I had the opportunity to build new web pages and redesign parts of the website and the blog. I even was built some jQuery scripts for our landing pages

I had to wear a lot of hats which gave me a serious appreciation for all the roles at a company. **Everyone has a hard job.** Everyone's work matters. That level of empathy is invaluable for anyone having to work across departments and teams.

# Missteps

## So! Many! Books!

![]()

I tried to learn programming the way I'd learned about the British Empire or Platonism or Medieval theology: **by reading.** Silly me!

However, it gave me so much context and deep understanding. Knowing JavaScript under the hood helps me intuitively read JS code faster. Reading about memory registers and assembly when I first became interested in programming helped me grok pointers in Go.

But eventually I realized I needed to learn by doing and not just by reading. Which leads to misstep #2...

## Perfectionism, Procrastination, and the Fear of Failure

Writing papers in college and blog posts for my company made me vigilant about mistakes. Once I submitted a paper or set a blog post live, it was out of my hands, free for people to pick apart and check for any grammatical errors.

I treated programming like that and was scared to code anything until I knew it would be perfect. But then I tried something audacious!

**I wrote code that I knew wouldn't work.** I wrote what I knew, looked at the errors I got, and iterated. I pushed my knowledge and skills, hit a wall, read up and filled in that gap, and coded until I hit a wall again. Wash. Rinse. Repeat.

**And the stakes are so low.** My compiler yelling at my local machine is fine. I didn't break something in production. I didn't mess up a teammate's code. Everything is okay. **I can keep try and failing and using those errors to improve my code and fill in skill gaps.**

## Starting with NodeJS

I knew I wanted to be a back-end developer and I picked JavaScript because that's what my company uses. But honestly, starting with NodeJS isn't the best idea in the world. I had to jump from 0 to 60, from "Hello, World" to event loops and asynchronous code and file IO and all the rest. I also wanted to build a web app so I was learning MongoDB as well.

I basically went from a few simple scripts to this huge [ME_N app I actually use to record my thoughts and keep track of notes](https://cpustejovsky-estuary.herokuapp.com). I learned **a lot** doing this, but there's a reason I recommend beginners start with Python.

# End of the Journey?

**Psych!** There is no end to the journey! I'm making incremental changes to my NodeJS app and am learning Golang in my freetime to help contribute to some open-source project I like. When I get a full-time job as a developer, the continuing education will, well, continue. I know you **have** to keep learning to stay relevant, but I love learning. It's honestly one of my best skills and my favorite things. I **get** to keep learning new things year after year.

Frankly, I can't wait to do this for the rest of my life. It feels like a blessing that I found a profession I love this much. I worried so much about ending up in a boring job that wouldn't challenge me and here I am getting closer, step by step, to my dream career.


